## Code is a means to an end

Code is the raw material we use to create software. It's inert like a lump of clay until we sculpt it with the tools and knowledge handed down from greater minds into some useful shape. Unlike clay, we can build systems whose complexity and efficiency boggle the mind. billions of messages can flow through a system every second without friction. There is also danger to the magic: a single thing out of place and the whole thing instantly grinds to a halt. If only our software could be as simple and dumb as a lump of clay!
All new code comes with a guarantee of bugs and other unknown issues. Over time we iron them out, and harden that code to serve its purpose really well. The problem comes when the people who built those things leave the company. The original knowledge that combined details of the real-world problem and the code implementation goes away. Sometimes if documentation is very well written it can help, but most often the intricacies of the developer's mind can't be expressed so simply, not to mention future plans and relations with other parts of the business and codebase. The problem can further be compounded if that person had specialised knowledge of the technology used for that solution, and if the solution is tightly coupled to the choice of technology. As such, new contributors invariably create problems when they begin contributing, until they eventually build up the knowledge and mastery of the original creator's intent. In this way a lot of software ends up developing with a "one step forward, two steps back" pattern, tied directly to the turnover rate of developers.
One obvious solution is to retain people for as long as possible, but in today's job market the best candidates are often changing companies regularly to capture the best compensation. Another approach that could transcend any individual is to foster a value of simplicity. It's an idea which we can apply to many dimensions: technology choice, working methodology, system design, and business structure. In each of these categories we should follow the old maxim: 'make it as simple as it can possibly be, but no simpler'.
Choice of technology is a good starting point. You likely are dealing with choices already made, and witnessing the ease or difficulty of building and running various systems. You probably have a deal with a third-party solution full of great features which provides a silver bullet for many of your technology problems — the integration of which may take another year or two. Was a true assessment made balancing the costs of integration with the possible gains? Perhaps, though the pain of integration is always understated by the providers, and possibly unforeseen by even veteran engineers. Maybe there's a missing dimension: tapping into the intuition and internal skills of the existing engineering team to come to a simple solution for the underlying problem. I have found the primary missing element is usually not technical ability, but rather communication and honest collaboration between engineers and other stakeholders.
Many engineers are by nature introverted, it is to some degree a requirement to become truly proficient with the perfect placement of commas, brackets, and other symbols of code language. Some of them need to live fully in the technological domain to tackle the hardest computer problems, but most of them can and should develop their ability to communicate outside of the purely technical. The origin of all the 'agile' and 'lean' ideas we now take for granted comes from the idea that we should carefully validate our ideas before we even think about code*. As such it is almost a guarantee that any developer can become more effective by improving their communication, their willingness to talk to marketers, salespeople, and executives, and their curiosity to truly understand the basic nature of the problems they're trying to solve.
My favourite activity when working on a codebase is removing code. There is so much bloat in today's software caused by adding libraries instead of deepening comprehension. One time I replaced a huge OAuth library integration with one line of code — the sophisticated framework gave the impression of a secure solution, but actually it was hiding the reality of a dead-simple MVP solution in dire need of an update. Once the refactor was done, we could look clear-eyed at the error of our application logic and incrementally improve it. So much code today works like this: libraries imported willy-nilly to paper over a gap in domain knowledge.
We should treat code for what it is, a means to an end. With code we can create something like a hammer, when needed it gets the job done well and otherwise sits at the ready. We can also create something like an inkjet printer: often breaks down, in need of costly ink, and difficult to move around. The real issue with a printer of course is that it has been rendered obsolete. A better use of time would be to update the system of whoever it is that is still requiring a paper copy. Similarly with code, we are too often building printers: complex solutions to the problems presented to us. We need to go back the basic problem by asking questions and being curious, to perhaps find out that the printer was needed to file a requisition for a workman to hammer in a nail — and then simply do the dirty work ourselves.


*Eric Ries, The Lean Startup
